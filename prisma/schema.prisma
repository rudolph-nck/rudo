generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SPECTATOR
  BOT_BUILDER
  DEVELOPER
  ADMIN
}

enum Tier {
  FREE
  BYOB_FREE
  BYOB_PRO
  SPARK
  PULSE
  GRID
  ADMIN
}

enum PostType {
  TEXT
  IMAGE
  VIDEO
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  name                String?
  handle              String?   @unique
  bio                 String?
  passwordHash        String?
  image               String?
  role                UserRole  @default(SPECTATOR)
  tier                Tier      @default(FREE)
  stripeCustomerId    String?   @unique
  stripeSubscriptionId String?
  stripePriceId       String?
  postCredits         Int       @default(0)
  emailVerified       DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  bots          Bot[]
  likes         Like[]
  comments      Comment[]
  follows       Follow[]
  apiKeys       ApiKey[]
  webhooks      Webhook[]
  notifications Notification[]
  sessions      Session[]
  accounts      Account[]

  @@index([handle])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Bot {
  id           String   @id @default(cuid())
  ownerId      String
  name         String
  handle       String   @unique
  bio          String?
  avatar       String?
  banner       String?
  personality  String?  @db.Text
  contentStyle String?  @db.Text
  niche        String?
  tone         String?
  aesthetic    String?
  artStyle     String?   @default("realistic")
  botType      String?   @default("person")   // person, character, object, ai_entity
  personaData  String?   @db.Text             // JSON blob storing type-specific persona details

  // Character reference — high-tier users upload a reference image
  // GPT-4o Vision analyzes it into a reusable description for consistent generation
  characterRef            String?          // URL to uploaded reference image
  characterRefDescription String?  @db.Text // AI-generated description of the character for prompt injection

  isVerified     Boolean  @default(false)
  isBYOB         Boolean  @default(false)
  deactivatedAt  DateTime?
  postsPerDay    Int      @default(1)
  isScheduled  Boolean  @default(false)
  lastPostedAt DateTime?
  nextPostAt   DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner    User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  posts    Post[]
  follows  Follow[]

  @@index([ownerId])
  @@index([handle])
  @@index([nextPostAt])
  @@map("bots")
}

model Post {
  id               String           @id @default(cuid())
  botId            String
  type             PostType         @default(IMAGE)
  content          String           @db.Text       // Caption text (NOT standalone — always accompanies media)
  mediaUrl         String?
  thumbnailUrl     String?
  videoDuration    Int?                             // Video length in seconds (6, 15, or 30)
  tags             String[]                         // Platform tags for discovery (NOT inline hashtags)
  moderationStatus ModerationStatus @default(PENDING)
  moderationNote   String?
  moderationScore  Float?
  moderationFlags  String[]
  moderatedAt      DateTime?
  viewCount        Int              @default(0)
  engagementScore  Float            @default(0)
  isAd             Boolean          @default(false)
  adUrl            String?
  adLabel          String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  bot      Bot       @relation(fields: [botId], references: [id], onDelete: Cascade)
  likes    Like[]
  comments Comment[]

  @@index([botId])
  @@index([createdAt])
  @@index([moderationStatus])
  @@index([engagementScore])
  @@map("posts")
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("likes")
}

model Comment {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  parentId  String?
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  post    Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([postId])
  @@index([parentId])
  @@map("comments")
}

model Follow {
  id        String   @id @default(cuid())
  userId    String
  botId     String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@unique([userId, botId])
  @@map("follows")
}

model ApiKey {
  id        String   @id @default(cuid())
  userId    String
  name      String
  key       String   @unique
  lastUsed  DateTime?
  createdAt DateTime @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@map("api_keys")
}

model ModerationLog {
  id        String           @id @default(cuid())
  postId    String
  action    ModerationStatus
  reason    String?
  flags     String[]
  score     Float?
  automated Boolean          @default(true)
  reviewerId String?
  createdAt DateTime         @default(now())

  @@index([postId])
  @@map("moderation_logs")
}

enum WebhookEvent {
  NEW_FOLLOWER
  NEW_COMMENT
  POST_TRENDING
  POST_MODERATED
  BOT_MILESTONE
}

model Webhook {
  id        String         @id @default(cuid())
  userId    String
  url       String
  secret    String
  events    WebhookEvent[]
  isActive  Boolean        @default(true)
  lastError String?
  lastFired DateTime?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("webhooks")
}

model WebhookDelivery {
  id         String   @id @default(cuid())
  webhookId  String
  event      String
  payload    String   @db.Text
  statusCode Int?
  response   String?  @db.Text
  success    Boolean  @default(false)
  attempts   Int      @default(1)
  createdAt  DateTime @default(now())

  @@index([webhookId])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

model Ad {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text
  mediaUrl    String?
  ctaText     String?
  ctaUrl      String?
  advertiser  String
  budget      Float    @default(0)
  spent       Float    @default(0)
  cpm         Float    @default(5)
  impressions Int      @default(0)
  clicks      Int      @default(0)
  isActive    Boolean  @default(true)
  targeting   String?  @db.Text
  startDate   DateTime @default(now())
  endDate     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
  @@map("ads")
}

enum NotificationType {
  NEW_POST
  NEW_FOLLOWER
  NEW_COMMENT
  NEW_LIKE
  BOT_MILESTONE
  SYSTEM
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

model RateLimit {
  id        String   @id @default(cuid())
  key       String   @unique
  count     Int      @default(0)
  window    DateTime
  createdAt DateTime @default(now())

  @@index([key, window])
  @@map("rate_limits")
}
