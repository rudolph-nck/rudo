generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SPECTATOR
  BOT_BUILDER
  DEVELOPER
  ADMIN
}

enum Tier {
  FREE
  BYOB_FREE
  BYOB_PRO
  SPARK
  PULSE
  GRID
  ADMIN
}

enum PostType {
  TEXT
  IMAGE
  VIDEO
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  name                String?
  handle              String?   @unique
  bio                 String?
  passwordHash        String?
  image               String?
  role                UserRole  @default(SPECTATOR)
  tier                Tier      @default(FREE)
  stripeCustomerId    String?   @unique
  stripeSubscriptionId String?
  stripePriceId       String?
  postCredits         Int       @default(0)
  trialEnd            DateTime?
  hasUsedTrial        Boolean   @default(false)
  suspendedAt         DateTime?
  suspendedReason     String?
  emailVerified       DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  bots          Bot[]
  likes         Like[]
  comments      Comment[]
  follows       Follow[]
  apiKeys       ApiKey[]
  webhooks      Webhook[]
  notifications Notification[]
  sessions      Session[]
  accounts      Account[]
  conversationsAsUser1 Conversation[] @relation("ConversationUser1")
  conversationsAsUser2 Conversation[] @relation("ConversationUser2")
  sentMessages         DirectMessage[]
  coachingNudges       CoachingNudge[]
  postFeedbacks        PostFeedback[]
  botThemes            BotTheme[]
  botMissions          BotMission[]

  @@index([handle])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Bot {
  id           String   @id @default(cuid())
  ownerId      String
  name         String
  handle       String   @unique
  bio          String?
  avatar       String?
  banner       String?
  personality  String?  @db.Text
  contentStyle String?  @db.Text
  niche        String?
  tone         String?
  aesthetic    String?
  artStyle     String?   @default("realistic")
  botType      String?   @default("person")   // person, character, object, ai_entity
  personaData  String?   @db.Text             // JSON blob storing type-specific persona details

  // Character reference — high-tier users upload a reference image
  // GPT-4o Vision analyzes it into a reusable description for consistent generation
  characterRef            String?          // URL to uploaded reference image
  characterRefDescription String?  @db.Text // AI-generated description of the character for prompt injection

  isVerified     Boolean  @default(false)
  isBYOB         Boolean  @default(false)
  isSeed         Boolean  @default(false)            // Platform-owned seed bot
  deactivatedAt  DateTime?
  postsPerDay    Int      @default(1)
  isScheduled  Boolean  @default(false)
  lastPostedAt DateTime?
  nextPostAt   DateTime?

  // Character Brain — stable numeric personality traits that influence all generation
  brainVersion       Int       @default(1)
  characterBrain     Json?                            // CharacterBrain v1 JSON
  brainUpdatedAt     DateTime?

  // Agent Loop (Phase 3) — autonomous behavior state
  agentMode          String?   @default("scheduled") // "scheduled" | "autonomous"
  lastPerceptionAt   DateTime?
  lastDecisionAt     DateTime?
  nextCycleAt        DateTime?
  agentCooldownMin   Int       @default(15)          // minutes between agent cycles

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner    User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  posts    Post[]
  follows  Follow[]
  strategy BotStrategy?
  coachingNudges CoachingNudge[]
  postFeedbacks  PostFeedback[]
  themes         BotTheme[]
  missions       BotMission[]
  effectUsages   BotEffectUsage[]

  @@index([ownerId])
  @@index([handle])
  @@index([nextPostAt])
  @@index([nextCycleAt])
  @@map("bots")
}

model Post {
  id               String           @id @default(cuid())
  botId            String
  type             PostType         @default(IMAGE)
  content          String           @db.Text       // Caption text (NOT standalone — always accompanies media)
  mediaUrl         String?
  thumbnailUrl     String?
  videoDuration    Int?                             // Video length in seconds (6, 15, or 30)
  tags             String[]                         // Platform tags for discovery (NOT inline hashtags)
  moderationStatus ModerationStatus @default(PENDING)
  moderationNote   String?
  moderationScore  Float?
  moderationFlags  String[]
  moderatedAt      DateTime?
  viewCount        Int              @default(0)
  engagementScore  Float            @default(0)
  effectId         String?                          // Effect used for this post's video
  effectVariant    String?                          // Which variant of the effect
  isAd             Boolean          @default(false)
  adUrl            String?
  adLabel          String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  bot       Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  effect    Effect?        @relation(fields: [effectId], references: [id])
  likes     Like[]
  comments  Comment[]
  feedbacks PostFeedback[]

  @@index([botId])
  @@index([createdAt])
  @@index([moderationStatus])
  @@index([engagementScore])
  @@map("posts")
}

enum EngagementOrigin {
  USER
  SEED
  SYSTEM
}

model Like {
  id        String       @id @default(cuid())
  userId    String
  postId    String
  origin    EngagementOrigin @default(USER)
  createdAt DateTime     @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("likes")
}

model Comment {
  id        String           @id @default(cuid())
  userId    String
  postId    String
  parentId  String?
  content   String           @db.Text
  origin    EngagementOrigin @default(USER)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  post    Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([postId])
  @@index([parentId])
  @@map("comments")
}

model Follow {
  id        String   @id @default(cuid())
  userId    String
  botId     String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@unique([userId, botId])
  @@map("follows")
}

model ApiKey {
  id        String   @id @default(cuid())
  userId    String
  name      String
  key       String   @unique
  lastUsed  DateTime?
  createdAt DateTime @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@map("api_keys")
}

model ModerationLog {
  id        String           @id @default(cuid())
  postId    String
  action    ModerationStatus
  reason    String?
  flags     String[]
  score     Float?
  automated Boolean          @default(true)
  reviewerId String?
  createdAt DateTime         @default(now())

  @@index([postId])
  @@map("moderation_logs")
}

enum WebhookEvent {
  NEW_FOLLOWER
  NEW_COMMENT
  POST_TRENDING
  POST_MODERATED
  BOT_MILESTONE
}

model Webhook {
  id        String         @id @default(cuid())
  userId    String
  url       String
  secret    String
  events    WebhookEvent[]
  isActive  Boolean        @default(true)
  lastError String?
  lastFired DateTime?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("webhooks")
}

model WebhookDelivery {
  id         String   @id @default(cuid())
  webhookId  String
  event      String
  payload    String   @db.Text
  statusCode Int?
  response   String?  @db.Text
  success    Boolean  @default(false)
  attempts   Int      @default(1)
  createdAt  DateTime @default(now())

  @@index([webhookId])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

model Ad {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text
  mediaUrl    String?
  ctaText     String?
  ctaUrl      String?
  advertiser  String
  budget      Float    @default(0)
  spent       Float    @default(0)
  cpm         Float    @default(5)
  impressions Int      @default(0)
  clicks      Int      @default(0)
  isActive    Boolean  @default(true)
  targeting   String?  @db.Text
  startDate   DateTime @default(now())
  endDate     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
  @@map("ads")
}

enum NotificationType {
  NEW_POST
  NEW_FOLLOWER
  NEW_COMMENT
  NEW_LIKE
  BOT_MILESTONE
  SYSTEM
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

model RateLimit {
  id        String   @id @default(cuid())
  key       String   @unique
  count     Int      @default(0)
  window    DateTime
  createdAt DateTime @default(now())

  @@index([key, window])
  @@map("rate_limits")
}

model Conversation {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  user1    User            @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User            @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages DirectMessage[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([updatedAt])
  @@map("conversations")
}

model DirectMessage {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  content        String   @db.Text
  read           Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("direct_messages")
}

// ---------------------------------------------------------------------------
// Coaching Portal — user coaching signals for bot personality tuning.
// ---------------------------------------------------------------------------

enum NudgeType {
  SLIDER_UPDATE
  THEME_SET
  POST_FEEDBACK
  MISSION_SET
  ARC_SET
}

enum FeedbackSignal {
  MORE_LIKE_THIS
  LESS_LIKE_THIS
  TOO_FORMAL
  TOO_CHAOTIC
  FUNNIER
  CALMER
  MORE_DIRECT
  MORE_POETIC
}

model CoachingNudge {
  id           String    @id @default(cuid())
  botId        String
  userId       String
  type         NudgeType
  payload      Json
  botAccepted  Boolean?              // null = not evaluated, true = accepted, false = rejected
  botResponse  String?   @db.Text    // Bot's explanation for why it accepted/rejected the nudge
  evaluatedAt  DateTime?             // When the bot evaluated this nudge
  createdAt    DateTime  @default(now())

  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([botId, createdAt])
  @@map("coaching_nudges")
}

model PostFeedback {
  id        String         @id @default(cuid())
  postId    String
  botId     String
  userId    String
  signal    FeedbackSignal
  note      String?
  createdAt DateTime       @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([botId, createdAt])
  @@index([postId])
  @@map("post_feedbacks")
}

model BotTheme {
  id        String    @id @default(cuid())
  botId     String
  userId    String
  theme     String
  intensity Float     @default(0.6)
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([botId])
  @@map("bot_themes")
}

model BotMission {
  id        String    @id @default(cuid())
  botId     String
  userId    String
  title     String
  target    Json
  active    Boolean   @default(true)
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  bot  Bot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([botId, active])
  @@map("bot_missions")
}

// ---------------------------------------------------------------------------
// Bot Strategy (Phase 5) — Learned content preferences from performance data.
// Updated by the learning loop after analyzing post performance.
// Read by the generation pipeline to bias format, topic, and hook selection.
// ---------------------------------------------------------------------------

model BotStrategy {
  id            String   @id @default(cuid())
  botId         String   @unique
  topicWeights  Json     @default("{}")  // { "tag": weight } — topics that perform well
  formatWeights Json     @default("{}")  // { "IMAGE": w, "VIDEO_6": w, "VIDEO_15": w, "VIDEO_30": w }
  hookWeights   Json     @default("{}")  // { "question": w, "statement": w, "exclamation": w, ... }
  postRateBias  Float    @default(0)     // -1 to 1, nudge posting frequency
  replyRateBias Float    @default(0)     // -1 to 1, nudge reply frequency
  updatedAt     DateTime @updatedAt

  bot Bot @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@map("bot_strategies")
}

// ---------------------------------------------------------------------------
// Content Effects Library — visual effects templates for video generation.
// Each effect defines a prompt template, camera config, variants, music mood,
// and cost estimates. Bots select effects based on mood, tier, and personality.
// ---------------------------------------------------------------------------

model EffectCategory {
  id           String   @id
  name         String
  icon         String
  displayOrder Int
  effects      Effect[]

  @@map("effect_categories")
}

model Effect {
  id              String   @id
  name            String
  categoryId      String
  tierMinimum     String                // "spark", "pulse", "grid"
  generationType  String                // "text_to_video", "image_to_video", "start_end_frame", "multi_scene", "code_render"
  description     String?  @db.Text
  cameraConfig    Json?                 // { movement, startFrame, endFrame }
  promptTemplate  Json                  // { main, scenes[] } — prompt with [SUBJECT] placeholder
  variants        Json?                 // [{ id, label, substitutions }]
  musicConfig     Json?                 // { mood, description }
  durationOptions Json                  // [10, 15, 30] — available durations in seconds
  fps             Int      @default(24)
  costEstimateMin Float?
  costEstimateMax Float?
  isActive        Boolean  @default(true)
  isTrending      Boolean  @default(false)
  usageCount      Int      @default(0)
  createdAt       DateTime @default(now())

  category EffectCategory   @relation(fields: [categoryId], references: [id])
  usages   BotEffectUsage[]
  posts    Post[]

  @@index([categoryId])
  @@index([tierMinimum])
  @@index([isActive, isTrending])
  @@map("effects")
}

model BotEffectUsage {
  id             String   @id @default(cuid())
  botId          String
  effectId       String
  variant        String?
  musicTrackId   String?
  generationCost Float?
  postId         String?
  createdAt      DateTime @default(now())

  bot    Bot    @relation(fields: [botId], references: [id], onDelete: Cascade)
  effect Effect @relation(fields: [effectId], references: [id])

  @@index([botId, createdAt])
  @@index([effectId])
  @@map("bot_effect_usage")
}

// ---------------------------------------------------------------------------
// Job Queue (Phase 2) — Postgres-backed job queue, no Redis needed.
// Jobs are claimed atomically with SELECT ... FOR UPDATE SKIP LOCKED
// to safely support concurrent workers.
// ---------------------------------------------------------------------------

enum JobType {
  GENERATE_POST
  CREW_COMMENT
  RECALC_ENGAGEMENT
  BOT_CYCLE
  RESPOND_TO_COMMENT
  RESPOND_TO_POST
  WELCOME_SEQUENCE
}

enum JobStatus {
  QUEUED
  RUNNING
  RETRY
  FAILED
  SUCCEEDED
}

model Job {
  id          String    @id @default(cuid())
  type        JobType
  status      JobStatus @default(QUEUED)
  botId       String?
  payload     Json      @default("{}")
  runAt       DateTime  @default(now())
  attempts    Int       @default(0)
  maxAttempts Int       @default(5)
  lockedAt    DateTime?
  lastError   String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status, runAt])
  @@index([botId])
  @@index([type])
  @@map("jobs")
}

// ---------------------------------------------------------------------------
// Admin API Credit Tracker — monitor external API connections, balances,
// spending, and alerts across all generation providers (MiniMax, Kling, etc.)
// ---------------------------------------------------------------------------

enum ProviderPurpose {
  VIDEO_GENERATION
  IMAGE_GENERATION
  AUDIO_GENERATION
  TEXT_GENERATION
  MULTI_PURPOSE
}

enum ConnectionStatus {
  CONNECTED
  DISCONNECTED
  ERROR
  LOW_BALANCE
  PENDING_TEST
}

enum UsageLogStatus {
  SUCCESS
  FAILED
  RATE_LIMITED
  INSUFFICIENT_CREDITS
}

enum BalanceChangeReason {
  API_CALL_USAGE
  MANUAL_TOPUP
  AUTO_TOPUP
  REFUND
  BALANCE_SYNC
}

enum AlertType {
  LOW_BALANCE
  BUDGET_EXCEEDED
  API_ERROR
  RATE_LIMITED
  DISCONNECTED
}

enum AlertSeverity {
  CRITICAL
  WARNING
  INFO
}

model ApiProvider {
  id                 Int              @id @default(autoincrement())
  providerName       String           @unique @db.VarChar(50)
  displayName        String           @db.VarChar(100)
  apiKey             String           @db.VarChar(500)
  apiSecret          String?          @db.VarChar(500)
  baseUrl            String?          @db.VarChar(255)
  currentBalance     Decimal          @default(0) @db.Decimal(12, 2)
  balanceCurrency    String           @default("USD") @db.VarChar(10)
  monthlyBudget      Decimal?         @db.Decimal(12, 2)
  alertThreshold     Decimal?         @db.Decimal(12, 2)
  purpose            ProviderPurpose  @default(MULTI_PURPOSE)
  capabilities       Json?
  usedForEffects     Json?
  priorityOrder      Int              @default(1)
  fallbackProviderId Int?
  isActive           Boolean          @default(true)
  connectionStatus   ConnectionStatus @default(PENDING_TEST)
  lastBalanceCheck   DateTime?
  lastSuccessfulCall DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  usageLogs        ApiUsageLog[]
  balanceHistory   ApiBalanceHistory[]
  monthlySummaries MonthlySpendingSummary[]
  alerts           ApiAlert[]
  fallbackProvider ApiProvider?  @relation("ProviderFallback", fields: [fallbackProviderId], references: [id])
  fallbackFor      ApiProvider[] @relation("ProviderFallback")

  @@map("api_providers")
}

model ApiUsageLog {
  id             Int            @id @default(autoincrement())
  botId          String?        @db.VarChar(50)
  providerId     Int
  effectId       String?        @db.VarChar(50)
  endpoint       String?        @db.VarChar(255)
  creditsUsed    Decimal        @default(0) @db.Decimal(10, 4)
  costUsd        Decimal        @default(0) @db.Decimal(10, 4)
  requestParams  Json?
  responseStatus Int?
  responseTimeMs Int?
  errorMessage   String?        @db.VarChar(500)
  postId         String?        @db.VarChar(50)
  status         UsageLogStatus @default(SUCCESS)
  createdAt      DateTime       @default(now())

  provider ApiProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId, createdAt])
  @@index([botId, createdAt])
  @@index([effectId])
  @@index([status])
  @@map("api_usage_logs")
}

model ApiBalanceHistory {
  id              Int                 @id @default(autoincrement())
  providerId      Int
  balanceSnapshot Decimal             @db.Decimal(12, 2)
  changeAmount    Decimal?            @db.Decimal(10, 4)
  changeReason    BalanceChangeReason @default(BALANCE_SYNC)
  createdAt       DateTime            @default(now())

  provider ApiProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId, createdAt])
  @@map("api_balance_history")
}

model MonthlySpendingSummary {
  id              Int      @id @default(autoincrement())
  year            Int
  month           Int
  providerId      Int
  totalCreditsUsed Decimal @default(0) @db.Decimal(12, 2)
  totalCostUsd    Decimal  @default(0) @db.Decimal(12, 2)
  totalApiCalls   Int      @default(0)
  successfulCalls Int      @default(0)
  failedCalls     Int      @default(0)
  avgCostPerCall  Decimal? @db.Decimal(10, 4)
  avgResponseTimeMs Int?
  topEffect       String?  @db.VarChar(50)
  topBot          String?  @db.VarChar(50)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  provider ApiProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([year, month, providerId])
  @@map("monthly_spending_summary")
}

model ApiAlert {
  id             Int           @id @default(autoincrement())
  providerId     Int
  alertType      AlertType
  message        String?       @db.Text
  severity       AlertSeverity @default(WARNING)
  isAcknowledged Boolean       @default(false)
  acknowledgedAt DateTime?
  triggeredAt    DateTime      @default(now())

  provider ApiProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId])
  @@index([isAcknowledged])
  @@map("api_alerts")
}
